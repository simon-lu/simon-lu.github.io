[{"content":"before 建立了两个repo, 一个是github page，另一个my_blog保存博客源代码，使用脚本来管理两个仓库，每次的更改都向两个仓库提交commit，不是那么的方便，后来发现了Travis CI。\nafter 由于有在多个系统上写博客的习惯，所以上述的流程显的过于繁琐，现在在github page仓库建立blog分支管理源代码，使用Travis CI监控blog分支的变化，自动构建hugo环境，部署到github page master。\n整个流程简化到在github page blog分支写博客，提交即可，不用再关心其他的东西。\n","description":"","id":2,"section":"posts","tags":["hugo"],"title":"使用Travis CI简化博客流程","uri":"https://simon-lu.github.io/en/posts/hugo-travisci/"},{"content":"尝试过Manjaro i3wm一段时间，还是喜欢Ubuntu 16.04经典版本，需要配置许多环境，为了方便以后查看，记录一下过程。\n基础环境 1. 连接wifi 首先要安装无线驱动，有两种解决方案。一种是连接网线，更新软件源，添加附加驱动；第二种是离线安装驱动，利用U盘目录中的pool-\u0026gt;restricted-\u0026gt;b-\u0026gt;bcmwl下的.deb文件，键入以下命令安装，如果发现缺少依赖，就到pool-\u0026gt;main下去找。\n1  sudo dpkg -i xxx.deb   2. 输入法 搜狗输入法 或 Rime\n3.改键位映射 由于笔记本Z键失灵，所以把Ctrl_R改为Z\n1  xmodmap -e \u0026#34;keycode 0x69 = z Z z Z\u0026#34;   4. home下目录更改为英文 5.git配置 1 2 3 4  sudo apt-get install git git config --global user.name \u0026#34;xxx\u0026#34; git config --global user.email \u0026#34;xxx\u0026#34; ssh-keygen -C \u0026#34;xxx\u0026#34; -t rsa   cd ~/.ssh，复制id_rsa.pub的内容\n6. hugo搭建的博客 1  sudo apt-get install hugo // 不推荐，因为版本过低，去官网下载   下载release版本速度太慢的话，在Windows下使用IDM下载\n7.网速显示 1 2 3  sudo add-apt-repository ppa:fossfreedom/indicator-sysmonitor sudo apt-get update sudo apt-get install indicator-sysmonitor   8.Oh My Zsh 1 2  sudo apt-get install zsh chsh -s $(which zsh)   Log out查看是否是默认shell，echo $SHELl\n使用install.sh文件来安装ohmyzshc\n9.时间同步 1  sudo timedatectl set-local-rtc 1   实用的软件 1. 护眼软件 \u0026ndash; redshift 晚上看屏幕还挺舒服，个人感觉比f.lux要好一些\n1  sudo apt-get install redshift   2. 美化一下下 更换壁纸\n安装软件\n1  sudo apt-get install unity-tweak-tool   安装主题\n1 2 3  sudo add-apt-repository ppa:noobslab/themes sudo apt-get update sudo apt-get install flatabulous-theme   更换图标\n1 2 3  sudo add-apt-repository ppa:noobslab/icons sudo apt-get update sudo apt-get install ultra-flat-icons   3. 浏览器 \u0026ndash; firefox 4. 截图软件 \u0026ndash; shutter 5.快捷启动 \u0026ndash; Albert 1 2 3  sudo add-apt-repository ppa:nilarimogard/webupd8 sudo apt-get update sudo apt-get install albert   ","description":"","id":3,"section":"posts","tags":["ubuntu","环境配置"],"title":"Ubuntu备忘录","uri":"https://simon-lu.github.io/en/posts/ubuntu-note/"},{"content":"引言  每个key-value都是由对象组成的\n key是字符串对象，值是五种对象中的一个（字符串、列表对象、哈希对象、集合对象、有序集合对象）\n数据结构与对象 简单动态字符串（SDS）","description":"","id":4,"section":"posts","tags":["redis","《Redis设计与实现》"],"title":"《Redis设计与实现》读书笔记","uri":"https://simon-lu.github.io/en/posts/redis-note/"},{"content":"Sample images from Pixabay\n","description":"cartoon gallery","id":5,"section":"gallery","tags":null,"title":"Cartoon","uri":"https://simon-lu.github.io/en/gallery/cartoon/"},{"content":"Sample images from Pixabay\n","description":"photo gallery","id":6,"section":"gallery","tags":null,"title":"Photo","uri":"https://simon-lu.github.io/en/gallery/photo/"},{"content":"-g 可在编译后的程序中保留调试符号信息\nstrip hello_server 移除程序中存在的调试信息，程序测试后没有问题，我们可以使用此命令减小程序体积,调试文件时建议关闭编译器优化选项，有可能会优化掉排查的对象\n三种调试方式  gdb filename 直接调试目标程序，然后 run gdb attach pid 程序已经启动，将 gdb 调试器附加到程序上，ps 命令获取改进程的 pid\n结束调试后使用 detach 来分离 gdb filename corename 程序崩溃时有 core 文件产生，可以使用 core 来定位问题\nulimit -c 查看是否开启了之一机制 ulimit -a 系统最大文件描述符\n\u0026ldquo;ulimit 选项名 设置值\u0026quot;来修改，例：ulimit -c unlimited,永久生效需要将此命令加入/etc/profile 文件中\ncore 文件的默认名字是 core.pid  core 文件 针对 core 文件，pid 在程序崩溃时候无法获取 pid，尤其多个程序同时崩溃时，解决方法有两个：\n 程序启动时候,记录自己的 pid  1 2 3 4 5 6 7 8 9 10 11  void writepid() { uint31_t curPid = (uint32_t) getpid(); FILE* f = fopen(\u0026#34;xxxserver.pid\u0026#34;, \u0026#34;w\u0026#34;); assert(f); char szPid[32]; snprintf(szPid, sizeof(szPid), \u0026#34;%d\u0026#34;, curPid); fwrite(szPid, strlen(szPid), 1, f); fclose(f); } // 生成的pid记录到xxxserver.pd文件中，崩溃时从此获取   自定义 core 文件的名称和目录\n/proc/sys/kernel/core_uses_pid 可以控制产生的 core 文件的文件名是否用 pid 作为扩展名，1 为添加，0 则否\n/proc/sys/kernel/core_pattern 可以设置格式化的 core 文件保存位置和文件名，命令如下：  1  echo \u0026#34;/corefile/core-%e-%p-%t\u0026#34; \u0026gt; /proc/sys/kernel/core_pattern   %e 代表充程序名，%p 代表 pid, %t 代表时间戳 例如/testcore/core-%e-%p-%t，将生成 core-test-13154-1547445291 这种格式\n常用命令    命令名称 缩写 说明     run r 运行   continue c 暂停的程序继续运行   next n 运行到下一行   step u 如果有函数，进入内部   until u 运行到指定行停下来   finish fi 结束当前调用函数，到上一层函数调用处   return return 结束当前调用函数并返回指定值，到上一层函数调用处   jump j 执行流跳转到指定行或地址   print p 打印变量或寄存器值   backtrace bt 查看当前线程调用堆栈   frame f 切换到当前线程调用的指定堆栈，可通过堆栈序号   thread thread 切换到指定线程   break b 添加断点   tbreak tb 添加临时断点   delete del 删除断点   enable enable 启用某个断点   disable disable 禁用某个断点   wathc watch 监视某一个变量或地址的值是否变化   list l 显示源码   info info 显示断点/线程等信息   ptype ptype 查看变量类型   disassemble dis 查看汇编代码   set args  设置程序启动命令行参数   show args  查看设置的命令行参数    print 和 ptype  print 不仅可以显示变量值，也可以进行一定运算表达式计算结果，甚至可以显示一些函数的执行结果 p \u0026amp;server.port 取地址，在 C++对象中，也可以 p this,也可以 p *this 列出当前对象各个成员的值 p a+b+c 来打印三个变量的计算结果，func()是可执行函数，也可以 p func()输出该变量的执行结果 print 也可以修改变量的值  info 和 thread  info thread 查看当前进程有哪些线程, 带*号表示当前 gdb 作用于哪个线程，谁是主线程可以 bt 查看调用堆栈 thread 线程编号 切换线程 info args 产看当前函数的参数值  next、step、until、jump  函数调用方式_cdelc 和_stdcall，C++非静态成员函数的调用方式_thiscall，函数参数的传递本质都是函数参数入栈的过程，者三种入栈方式都是从右往左的 直接执行完当前函数并回到上一层调用处，使用 finish return 与之类似，可以指定该函数返回值\nNote: finish 会执行函数到函数正常退出该函数；而 return 是立即结束当前函数并返回，如果说当前函数还有剩余的代码未执行完毕，也不会执行了 until 快速执行完中间代码 jump  location 可以是行号或者函数的地址，行为是不可控的\n如果 jump 跳转的位置后续没有断点，gdb 会执行完跳转处的代码继续执行\njump 妙用：可以执行一些我们想要执行的代码，可能这些代码在正常逻辑下不会执行,如下：  1 2 3 4 5 6 7 8 9 10  int main() { int a = 0; if (a != 0 ) { printf(\u0026#34;if condition\\n\u0026#34;); } else { printf(\u0026#34;else condition\\n\u0026#34;); } return 0; }   正常是走 else 分支，可以使用 jump 强制走 if，return 0 设为断点，gdb 会停下\ndisassemble  disassemble 查看汇编指令，默认为 AT\u0026amp;T 格式，可以通过 show disassembly-flavor 查看，通过 set disassembly-flavor intel 设置为 intel 汇编格式 set args 和 show args\ngdb filename args 是错误做法，应该是 gdb 附加程序后，在 run 命令前，使用\u0026quot;set args 参数内容\u0026quot;来设置，例如：set args ../redis.conf\n如果单个命令行参数之间含有空格，可以使用引号将参数包裹起来，如：set args \u0026ldquo;999 xx\u0026rdquo; \u0026ldquo;hu jj\u0026rdquo;\n清除参数,直接使用 set args 不加任何参数 tbreak 该断点触发一次就会自动删除 watch 通过添加硬件断点来达到监视数据变化的目的，有以下几种形式:\n(1) 整形变量, int i; wathc i\n(2) 指针类型， char *p; watch p 与 wathc *p,两种是有区别的\n(3) 一个数组或内存区间， char buf[128]; wathc buf display 命令监视的变量或者内存地址，每次程序中断下来都会自动输出这些变量或者内存的值\ninfo display 查看， delete display 清除全部需自动输出的变量，加编号删除某一个\ndisplay $ebp 添加寄存器 ebp  调试技巧  print 打印结果显示完整\n打印字符串或字符数组时，字符串太长显示不全，使用 set print element 0 命令设置就可以完整显示了 gdb 调试的程序接收信号\n例如 Ctrl+C(对应信号 SIGINT)，Ctrl+C 会被 gdb 接收到，程序无法接收，两种方式:\n(1) gdb 中使用 signal 函数手动发送信号给程序， signal SIGINT;\n(2) 改变 gdb 信号处理的设置，通过 handle SIGINT nostop print pass 告诉 gdb 接收到 SIGINT 不要停止，传给程序 函数存在，但是添加断点无效\n这时候需要改变方式，使用代码文件和行号这种方式 多线程下禁止线程切换\nset scheduler-locking on 将执行流锁定在当前调试线程 条件断点\nbreak [lineNo] if [condition]\n还有一种方式，先添加断点，然后使用\u0026quot;condition 断点编号 断点触发条件\u0026rdquo;，例如: (gdb)b 11 (gdb) condition 1 i == 500 gdb 调试多进程\n(1)先调试父进程，子进程 fork 出来后，使用 gdb attach 到子进程，这需要重新开一个 session 窗口调试\n(2)gdb 提供了一个选项 follow-fork,可以使用 show follow-fork mode 查看当前值，也可以通过 set follow-fork mode 设置是当一个进程 fork 出新的子进程时，gdb 是继续调试父进程还是子进程(取值 child)，默认取(parent)  自定义 gdb 调试命令 在当前用户(home)目录下，root(/root),非 root(/home/用户名)下，自定义.gdbinit 文件\nRedis 的调试","description":"","id":11,"section":"posts","tags":["gdb"],"title":"如何使用GDB调试项目","uri":"https://simon-lu.github.io/en/posts/how-to-use-gdb/"},{"content":"My Github chart:\n","description":"Hugo, the world’s fastest framework for building websites","id":12,"section":"","tags":null,"title":"About","uri":"https://simon-lu.github.io/en/about/"}]